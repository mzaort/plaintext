goog.provide('plaintext.View');
goog.provide('plaintext.View.Classes');
goog.provide('plaintext.View.ComponentConstructor');
goog.provide('plaintext.View.EventType');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.async.nextTick');
goog.require('goog.dom');
goog.require('goog.dom.classlist');
goog.require('goog.dom.dataset');
goog.require('goog.events');
goog.require('goog.events.Event');
goog.require('goog.events.EventTarget');
goog.require('goog.object');
goog.require('goog.string');
goog.require('goog.structs.Map');
goog.require('goog.ui.Button');
goog.require('goog.ui.Component');
goog.require('goog.ui.Menu');
goog.require('plaintext.util.UidMap');

/**
 * @constructor
 * @extends {goog.events.EventTarget}
 */
plaintext.View = function() {
  goog.base(this);

  /**
   * @private
   * @type {!goog.structs.Map.<string, !plaintext.View.ComponentConstructor>}
   */
  this.componentConstructors_ = new goog.structs.Map();

  /**
   * @private
   * @type {!plaintext.util.UidMap.<!goog.ui.Component, Function(Object)>}
   */
  this.constructorWrapper_ = new plaintext.util.UidMap();

  /**
   * A map from elements to component instances for which they are created. It holds all component instances both
   * decorated and undecorated as its value set.
   * 
   * @private
   * @type {!plaintext.util.UidMap.<!Element, !goog.ui.Component>}
   */
  this.componentInstances_ = new plaintext.util.UidMap();

  /**
   * A map from component instances to their element. Because we cannot call .setElementInternal(element) on undecorated
   * components, we keep this information here to be used in decorateChildren(container).
   * 
   * @private
   * @type {!plaintext.util.UidMap.<!goog.ui.Component, !Element>}
   */
  this.undecoratedComponents_ = new plaintext.util.UidMap();

  /**
   * @private
   * @type {!goog.structs.Map.<!string, !function>}
   */
  this.componentGenerators_ = new goog.structs.Map();

  /**
   * @private
   * @type {boolean}
   */
  this.finishInitialize_ = false;
};
goog.inherits(plaintext.View, goog.events.EventTarget);
goog.addSingletonGetter(plaintext.View);

/**
 * @typedef {function(new:goog.ui.Component, ?, goog.dom.DomHelper=)}
 */
plaintext.View.ComponentConstructor;

/**
 * @enum {string}
 */
plaintext.View.Classes = {
  COMPONENT : 'component',
  COMPONENT_PREFIX : 'component-'
};

/**
 * @enum {Object}
 */
plaintext.View.REGISTER = {
  'component-input-button' : {
    ctor : goog.ui.Button,
    paramKeys : [ 'content', 'renderer', 'domHelper' ]
  },
  'component-simple-menu' : {
    ctor : goog.ui.Menu,
    paramKeys : [ 'domHelper', 'renderer' ]
  }
};

/**
 * @type {Array}
 */
plaintext.View.metaKeyList = [ 'label', 'hint', 'visible', 'readonly', 'disabled', 'required', 'dateType', 'maxlength',
    'minlength', 'maxdecimal', 'maxval', 'minval', 'maxdate', 'mindate', 'pattern', 'charset', 'enable-chars',
    'disable-chars', 'example', 'validationMsgJson', 'useAutoComplete', 'autoCompleteEntity',
    'autoCompleteConditionFields', 'autoCompleteFetchFields', 'autoCompleteHintFields', 'autoCompleteUrl',
    'divisionList', 'autofocus', 'defaultValue' ];

/**
 * Register a new component.
 * 
 * @param {string} name JS class name to trigger instantiation of the component.
 * @param {!plaintext.View.ComponentConstructor} ctor The constructor of the component.
 * @param {Function.<Object>=} opt_wrapper a function to build ctor accepting Object as parameter
 */
plaintext.View.registerComponent = function(name, ctor, opt_wrapper) {
  var cssName = name.toLowerCase().replace(/\./g, '-');
  plaintext.View.getInstance().componentConstructors_.set(cssName, ctor);
  plaintext.View.getInstance().constructorWrapper_.set(ctor, opt_wrapper);
};

/**
 * Put component generator generated by component insertion function
 * 
 * @param {string} component css class name
 * @param {function()} component generator
 */
plaintext.View.addComponentGenerator = function(name, generator) {
  var cssName = name.toLowerCase().replace(/\./g, '-');
  plaintext.View.getInstance().componentGenerators_.set(cssName, generator);
};

/**
 * 
 * @this {view:!plaintext.View, targetElement:!Element}
 * @private
 */
plaintext.View.componentDispose_ = function() {
  var element = this.targetElement;
  var view = this.view;
  view.componentInstances_.remove(element);
  goog.dom.removeNode(element);
};

goog.scope(function() {

  var View = plaintext.View;

  /**
   * Get the component instance generated for the given element / the element with the given id.
   * 
   * @param {string|!Element|null} idOrElement
   * @return {?goog.ui.Component} the component with the given id
   */
  View.prototype.getComponent = function(idOrElement) {
    var element = goog.dom.getElement(idOrElement);
    if (!element) {
      return null;
    }
    var component = (this.componentInstances_.get(element));
    return component;
  };

  /**
   * Returns true if the view has component constructed by constructor for given element.
   * 
   * @param {!Element} element
   * @param {!Function} constructor
   * @return {boolean}
   */
  View.prototype.hasComponent = function(element, ctor) {
    if (this.componentInstances_.containsKey(element)) {
      if (!ctor) {
        return true;
      }
      return this.componentInstances_.get(element).constructor === ctor;
    }
    return false;
  };

  /**
   * The types of events fired by this class.
   * 
   * @enum {string}
   */
  plaintext.View.EventType = {
    START_INITIALIZE : goog.events.getUniqueId('view-initialize-start'),
    FINISH_INITIALIZE : goog.events.getUniqueId('view-initialize-finish')
  };

  /**
   * Search DOM tree under root and create components. Set this.componentInstances_ and this.undecoratedComponents_
   * appropriately.
   * 
   * @private
   * @param {?Element} root
   * @param {!Object} defaultParams
   * @return {plaintext.util.UidMap}
   */
  View.prototype.createComponentInstances_ = function(root, defaultParams) {
    var filterParentElement = root ? (root.parentElement ? root.parentElement : root) : goog.dom.getDocument();
    var result = new plaintext.util.UidMap();
    this.componentConstructors_.forEach(function(ctor, name) {
      var elements = goog.array.filter(goog.dom.getElementsByTagNameAndClass(null, name, filterParentElement),
          function(element) {
            return !this.hasComponent(element, ctor);
          }, this);
      goog.array.forEach(elements, function(element) {
        var id = element.id;
        var param = defaultParams[id] || {};
        var component;

        goog.mixin(param, goog.dom.dataset.getAll(element));
        component = this.assembleComponent(ctor, param);
        component.addOnDisposeCallback(plaintext.View.componentDispose_, {
          view : this,
          targetElement : element
        });
        result.set(element, component);
        this.componentInstances_.set(element, component);
        this.undecoratedComponents_.set(component, element);
      }, this);
    }, this);
    return result;
  };

  /**
   * @param {Function} ctor
   * @param {Object=} opt_params
   */
  View.prototype.assembleComponent = function(ctor, opt_params) {
    var wrapper = this.constructorWrapper_.get(ctor);
    if (goog.isFunction(wrapper)) {
      return wrapper(opt_params || {});
    } else {
      return goog.isObject(opt_params) && !goog.object.isEmpty(opt_params) ? new ctor(opt_params) : new ctor();
    }
  };

  /**
   * Initialize the view
   * 
   * @param {Object=} opt_defaultParams This parameter is for legacy use only. DO NOT USE.
   */
  View.prototype.initialize = function(opt_defaultParams) {
    goog.ui.Component.setDefaultRightToLeft(false);
    this.dispatchEvent(new goog.events.Event(plaintext.View.EventType.START_INITIALIZE, this));
    this.registerLabeledComponents();
    this.decorateAll(!!opt_defaultParams ? opt_defaultParams : {}, null);
    this.dispatchEvent(new goog.events.Event(plaintext.View.EventType.FINISH_INITIALIZE, this));
    this.finishInitialize_ = true;
  };

  /**
   * Register directly create a component based its class setting.
   */
  View.prototype.registerLabeledComponents = function() {
    var elements = goog.dom.getElementsByClass(plaintext.View.Classes.COMPONENT);
    if (goog.isArrayLike(elements)) {
      goog.array.forEach(elements, function(element) {
        this.registerLabeledElement(element);
      }, this);
    }
  };

  /**
   * Get the registered class info to its component constructor
   * @param {!Element} element
   * @return {boolean}
   */
  View.prototype.registerLabeledElement = function(element) {
    if (goog.dom.classlist.contains(element, plaintext.View.Classes.COMPONENT)) {
      var componentNames = this.getLabelsOfElement(element);
      if (componentNames.length !== 1) {
        return false;
      } else {
        var builder = this.getComponentBuilder(componentNames[0]);
        View.registerComponent(componentNames[0], builder.ctor, builder.wrapper);
        return true;
      }
    }
  };

  /**
   * Get the registered class info to its component constructor
   * @param {!Element} element
   * @return {!Array}
   */
  View.prototype.getLabelsOfElement = function(element) {
    return goog.array.filter(goog.dom.classlist.get(element) || [], function(className) {
      return goog.string.startsWith(className, plaintext.View.Classes.COMPONENT_PREFIX)
          && goog.isDefAndNotNull(this.getComponentBuilder(className));
    }, this);
  };

  /**
   * @param {Object} builder
   * @return {Function=}
   * @private
   */
  View.prototype.wrapperConstructor_ = function(builder) {
    if (goog.isArray(builder.paramKeys) && builder.paramKeys.length !== 0) {
      return function(obj) {
        obj = obj || {};
        var params = goog.array.map(builder.paramKeys, function(key) {
          return obj[key];
        });
        var component = {};
        var fun = Object.setPrototypeOf || function(obj, proto) {
          obj.__proto__ = proto;
          return obj;
        };
        fun(component, builder.ctor.prototype);
        builder.ctor.apply(component, params);
        return component;
      };
    }
  };

  /**
   * Get the constructor of a component from its className
   * 
   * @param {!string} className
   * @return {Function}
   */
  View.prototype.getComponentBuilder = function(className) {
    if (goog.string.isEmptySafe(className)) return null;
    var builder = View.REGISTER[className];
    if (builder == null) return null;

    return {
      ctor : builder.ctor,
      wrapper : this.wrapperConstructor_(builder)
    };
  };

  /**
   * whether initialization is finished.
   * 
   * @return {boolean}
   */
  View.prototype.isFinishInitialize = function() {
    return this.finishInitialize_;
  };

  /**
   * get component constructor by component js class
   * 
   * @param {string} componentJsClass JS classname to trigger instanciation of the component.
   * @return {?plaintext.View.ComponentConstructor}
   */
  View.prototype.getComponentConstructor = function(componentJsClass) {
    return this.componentConstructors_.get(componentJsClass);
  };

  View.prototype.getComponentGenerator = function(componentJsClass) {
    return this.componentGenerators_.get(componentJsClass);
  };

  /**
   * Decorate all components that are found below the root, except for those managed by another container component.
   * 
   * @param {!Object} defaultParams
   * @param {?Element} root
   */
  View.prototype.decorateAll = function(defaultParams, root) {
    /**
     * @const
     * @type {!Array.<!{ element: !Element, component: !goog.ui.Component }>}
     */
    var decorateList = [];
    var newComponentInstances = this.createComponentInstances_(root, defaultParams);
    newComponentInstances.forEach(function(component, element) {
      /**
       * @type {?Element}
       */
      var e = element;
      /**
       * @type {?Element}
       */
      var p = null;
      /**
       * @type {?goog.ui.Component}
       */
      var parentComponent = null;

      var stopElement = root ? (root.parentElement ? root.parentElement : root) : null;

      while ((p = e.parentElement) !== stopElement) {
        parentComponent = (p !== null) ? this.getComponent(p) : null;
        if (parentComponent) {
          parentComponent.addChild(component);
          break;
        }
        e = p;
      }
      if (!parentComponent) {
        decorateList.push({
          'element' : element,
          'component' : component
        });
      }
    }, this);

    var lazyComponents = [];

    goog.array.forEach(decorateList, function(entry) {
      var element = entry['element'];
      var component = entry['component'];

      if (goog.dom.dataset.get(element, 'lazy') === 'client') {
        lazyComponents.push(entry);
        return;
      }
      component.decorate(element);
      this.undecoratedComponents_.remove(component);
    }, this);

    this.lazyDecorate(lazyComponents);
  };

  /**
   * Decorate all components that are found below the root, no calling on lazy component decoration
   * 
   * @param {!Object} defaultParams
   * @param {?Element} root
   */
  View.prototype.decorateComponentsUnderRoot = function(defaultParams, root) {
    /**
     * @const
     * @type {!Array.<!{ element: !Element, component: !goog.ui.Component }>}
     */
    var decorateList = [];
    var newComponentInstances = this.createComponentInstances_(root, defaultParams);
    newComponentInstances.forEach(function(component, element) {
      /**
       * @type {?Element}
       */
      var e = element;
      /**
       * @type {?Element}
       */
      var p = null;
      /**
       * @type {?goog.ui.Component}
       */
      var parentComponent = null;

      var stopElement = root ? (root.parentElement ? root.parentElement : root) : null;

      while ((p = e.parentElement) !== stopElement) {
        parentComponent = (p !== null) ? this.getComponent(p) : null;
        if (parentComponent) {
          parentComponent.addChild(component);
          break;
        }
        e = p;
      }
      if (!parentComponent || parentComponent === this.getComponent(root)) {
        decorateList.push({
          'element' : element,
          'component' : component
        });
      }
    }, this);

    goog.array.forEach(decorateList, function(entry) {
      var element = entry['element'];
      var component = entry['component'];
      component.decorate(element);
      this.undecoratedComponents_.remove(component);
    }, this);
  };

  /**
   * 
   * @param {Array. <{component:goog.ui.Component,element:Element}>} lazyComponents
   */
  View.prototype.lazyDecorate = function(lazyComponents) {
    if (lazyComponents.length === 0) {
      return;
    }
    var self = this;
    goog.async.nextTick(function() {
      goog.array.forEach(lazyComponents, function(entry) {
        try {
          var element = entry['element'];
          var component = entry['component'];
          component.decorate(element);
          self.undecoratedComponents_.remove(component);
        } catch (e) {}
      });
    });
  };

  /**
   * @param {!goog.ui.Component} container A container component whose children this function decorates.
   */
  View.prototype.decorateChildren = function(container) {
    if (!container.hasChildren()) {
      // Hot fix lazy decorate
      var $element = container.getContentElement() || container.getElement();
      if (!$element || !goog.dom.getElementByClass('component', $element)) {
        return;
      }
      goog.array.forEach(goog.dom.getChildren($element), function($child) {
        this.decorateAll({}, $child);
      }, this);
      return;
    }
    var lazyComponents = [];
    container.forEachChild(function(child) {
      var elem = this.undecoratedComponents_.get(child);
      if (elem) {
        // the `decorate` method will check inDocument_ flag
        // first.
        if (goog.dom.dataset.get(elem, 'lazy') === 'client') {
          lazyComponents.push({
            'element' : elem,
            'component' : child
          });
          return;
        }
        child.decorate(elem);
        this.undecoratedComponents_.remove(child);
      }
    }, this);
    this.lazyDecorate(lazyComponents);
  };

  /**
   * return component instances
   * 
   * @return Array of container instances
   */
  View.prototype.getComponents = function() {
    var arr = [];
    goog.array.forEach(this.componentInstances_.getValues(), function(instance) {
      arr.push(instance);
    }, this);
    return arr;
  };

  /**
   * return specified type component instances
   * 
   * @param {function} Constructor of instance.
   * @return {Array.<goog.ui.Component>} Array of container instances
   */
  View.prototype.getComponentsByType = function(instanceType) {
    var arr = this.componentInstances_.getValues();
    return goog.array.filter(arr, function(component) {
      return component instanceof instanceType;
    }, this);
  };

  /**
   * Insert component to a container component. This new component will be appended to the end of the container
   * component.
   * 
   * @param {string} componentName The component name registered by plaintext.View.registerComponent
   * @param {object} option Option that used as tag attributes.
   * @param {object} data Value object that used in component.
   * @param {goog.ui.Component} parantComponent Parent component that this new component will be inserted into
   * @return {goog.ui.Component} Newly created component
   */
  View.prototype.insertComponentInto = function(componentName, option, data, parentComponent) {
    return this.insertComponent_(componentName, option, data, parentComponent, false);
  };

  /**
   * Insert component. This new component will be appended before the specified component
   * 
   * @param {string} componentName The component name registered by plaintext.View.registerComponent
   * @param {object} option Option that used as tag attributes.
   * @param {object} data Value object that used in component.
   * @param {goog.ui.Component} siblingComponent Sibling component that this new component will be inserted before
   * @return {goog.ui.Component} Newly created component
   */
  View.prototype.insertComponentBefore = function(componentName, option, data, siblingComponent) {
    return this.insertComponent_(componentName, option, data, siblingComponent, true);
  };

  /**
   * Insert a new component to specified element as its child element or sibling.
   */
  View.prototype.insertComponent_ = function(componentName, option, data, toComponent, asSibling) {

    // parameters checking:
    goog.asserts.assertString(componentName, 'componentName should be a string');
    var componentName = componentName.toLowerCase().replace(/\./g, '-');
    goog.asserts.assertInstanceof(toComponent, goog.ui.Component,
        'target component should be a instance of "goog.ui.Component"');
    option = option || {};
    data = data || {};
    this.handleComponentOptions_(option, data);

    // create element:
    var generator = this.getComponentGenerator(componentName);
    goog.asserts.assertFunction(generator,
        'This ui component can not be inserted. Please add <?will-insert ?> processing instruction.');
    var componentDomString = generator(option, data);
    var $componentElement = goog.dom.safeHtmlToNode(componentDomString);
    $componentElement.classList.add(componentName);

    // insert element:
    var $toComponentElement = toComponent.getElement();
    goog.asserts.assertElement($toComponentElement);

    if (asSibling) {
      var $parent = $toComponentElement.parentElement;
      goog.asserts.assertElement($parent);
      $parent.insertBefore($componentElement, $toComponentElement);
    } else {
      $toComponentElement.appendChild($componentElement);
    }

    // construct component:
    this.decorateAll({}, $componentElement);
    var newComponent = this.getComponent($componentElement);
    return newComponent;
  };

  /**
   * @param {Object} option
   * @param {Object} data
   * @private
   */
  View.prototype.handleComponentOptions_ = function(option, data) {
    goog.array.forEach(View.metaKeyList, function(metaKey) {
      if (option[metaKey] !== undefined && option[metaKey] !== null) {
        data[metaKey] = option[metaKey];
        option[metaKey] = metaKey;
      }
    });
  };

}); // goog.scope
